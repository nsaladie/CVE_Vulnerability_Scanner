from gpt4all import GPT4All
import requests, re, argparse

fixed_versions = []

# CVE-2023-38408
# SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.1


def check_vulnerability(cve_id: str, version: str):
    """Report if the ssh-ubuntu is vulnerable or not to CVE

    Args:
        cve_id: The identification of the CVE
        version: The version of the ssh and ubuntu

    Returns:
        If the version is vulnerable or not to the CVE
    """
    # Construct the URL to fetch CVE details
    url = f"https://ubuntu.com/security/cves/{cve_id}.json"
    response = requests.get(url)

    if response.status_code != 200:
        raise Exception("CVE information not found")

    data_response = response.json()
    # Save the information obtained from a part of the response json
    info_cve = data_response.get("packages", [])

    combined_version = get_correct_user_version(version)

    for package in info_cve:
        for status in package.get("statuses", []):
            description = status.get("description", "")
            status_version = status.get("status", "")
            if description and status_version == "released":
                fixed_versions.append(description)

    # Check if any fixed version matches the user's version partially
    ubuntu_version_fixed = get_fixed_version(combined_version)
    if not fixed_versions or ubuntu_version_fixed == False:
        return None

    for version in fixed_versions:
        fixed_version_split = version.rsplit("-", 1)[0]  # 1:8.9p1 -> 1:8.9p1-3ubuntu0.3
        # If the version of the user start like the fixed_version
        if combined_version.startswith(fixed_version_split):
            user_last_number = extract_last_number(
                combined_version
            )  # Extracts '0.10' from '1:8.9p1-3ubuntu0.10'
            fixed_last_number = extract_last_number(
                version
            )  # Extracts '0.3' from '1:8.9p1-3ubuntu0.3'
            if compare_versions(user_last_number, fixed_last_number):
                return False

    return True


def get_correct_user_version(version):
    """Extract and combine versions from the input using regex"""
    ssh_pattern = r"SSH-\d+\.\d+-OpenSSH_(\S+)\s+Ubuntu-(\S+)"
    generic_pattern = r"(\d+\.\d+\.\d+)-(.*)"
    mariadb_pattern = r"(\d+\.\d+\.\d+)-MariaDB-(\d+ubuntu\d+\.\d+[\.\da-zA-Z]*)"

    # Try to match the SSH pattern first
    match = re.search(ssh_pattern, version)
    if not match:
        # If no SSH match, try the generic_pattern pattern
        match = re.search(generic_pattern, version)
    if not match:
        # If no generic match, try the MariaDB pattern
        match = re.search(mariadb_pattern, version)

    if match:
        version = match.group(1)
        path = match.group(2)
        combined_version = f"1:{version}-{path}"
        return combined_version


def extract_last_number(version_string):
    """Extracts the last numerical part from a version string."""
    # Extracts '0.1' from '1:8.9p1-3ubuntu0.1'
    version_match = re.search(r"(\d+(?:\.\d+)*)$", version_string)
    return version_match.group(1) if version_match else ""


def compare_versions(user_version, fixed_version):
    """Compares two version strings numerically."""
    user_parts = list(map(int, user_version.split(".")))
    fixed_parts = list(map(int, fixed_version.split(".")))
    return user_parts >= fixed_parts


def get_fixed_version(user_version):
    for version in fixed_versions:
        fixed_version_split = version.rsplit("-", 1)[0]
        if user_version.startswith(fixed_version_split):
            return version
    return False


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Pass the CVE identification and SSH user version"
    )
    parser.add_argument("cve_id", help="CVE Identification", type=str)
    parser.add_argument("version", help="SSH-Ubuntu version", type=str)
    args = parser.parse_args()

    cve_id = args.cve_id
    version = args.version

    is_vulnerable = check_vulnerability(cve_id, version)

    combined_version = get_correct_user_version(version)
    ubuntu_version_fixed = get_fixed_version(combined_version)

    print("RESPONSE OF THE PYTHON PROGRAM:")

    if is_vulnerable:
        print(f"The version: {version} is vulnerable to {cve_id}")
    elif is_vulnerable == False:
        print(f"The version: {version} is NOT vulnerable to {cve_id}")
    else:
        print(
            f"No fixed versions have been found for this {version} version in this {cve_id}"
        )

    if ubuntu_version_fixed == False:
        response = "NULL"

    model = GPT4All("Meta-Llama-3-8B-Instruct.Q4_0.gguf")
    with model.chat_session():
        prompt = (
            "You are responsible for parsing a banner representing the version of some software, and outputting a JSON in standard format. The banner may have different formats, here are a few examples:\n"
            "I want that when I ask you to pass me to a JSON format you return me this data: version and path.\n"
            "Given this string 'SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.10', you should output: \n"
            "{"
            "version: 8.9p1"
            "path: 0.10"
            "}"
            f"It is important to output a valid JSON. Please parse the following string: {version}.\n"
            f"It is important to output a valid JSON. Please parse the following string: {ubuntu_version_fixed}.\n"
            f"Is the user's version: {version} in JSON lower than the {ubuntu_version_fixed} in JSON? Answer with 'YES' or 'NO'.\n"
            "Consider that version numbers should be compared numerically, and any part after the dash should also be compared numerically."
        )
        response = model.generate(prompt, max_tokens=1024)

    print("RESPONSE OF GPT4ALL:")
    if "YES" in response:
        print(f"The user's version is: Vulnerable to {cve_id}")
    elif "NO" in response:
        print(f"The user's version is: NOT vulnerable to {cve_id}")
    else:
        print(
            f"No fixed versions have been found for this version in this {version} in this {cve_id}"
        )
