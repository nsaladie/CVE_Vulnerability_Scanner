from gpt4all import GPT4All
import requests, re, argparse, json

fixed_versions = []

# CVE-2023-38408
# SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.1


def check_vulnerability(cve_id: str, version: str, release: str):
    """Report if the ssh-ubuntu is vulnerable or not to CVE

    Args:
        cve_id: The identification of the CVE
        version: The version of the ssh and ubuntu

    Returns:
        If the version is vulnerable or not to the CVE
    """
    # Construct the URL to fetch CVE details
    url = f"https://ubuntu.com/security/cves/{cve_id}.json"
    response = requests.get(url)

    if response.status_code != 200:
        raise Exception("CVE information not found")

    data_response = response.json()
    # Save the information obtained from a part of the response json
    info_cve = data_response.get("packages", [])

    combined_version = parse_version(version)

    for package in info_cve:
        for status in package.get("statuses", []):
            description = status.get("description", "")
            status_version = status.get("status", "")
            version_realse = status.get("release_codename", "")
            if description and status_version == "released":
                fixed_versions.append((version_realse, description))

    # Check if any fixed version matches the user's version partially
    ubuntu_version_fixed = get_fixed_version(combined_version, release, fixed_versions)
    if not fixed_versions or ubuntu_version_fixed == False:
        return None
    else:
        user_last_number = sanitize_path(combined_version)
        fixed_last_number = sanitize_path(ubuntu_version_fixed)
        if compare_versions(user_last_number, fixed_last_number):
            return False

    return True


def parse_version(version):
    """Extract and combine versions from the input using regex"""
    ssh_pattern = r"SSH-\d+\.\d+-OpenSSH_(\S+)\s+Ubuntu-(\S+)"
    generic_pattern = r"^([0-9p.]+)\s\w+\s(.+)$"
    bind_pattern = r"^\d:(.+?)(?:-|$)(.*)$"
    mariadb_pattern = r"(\d+\.\d+\.\d+)-MariaDB-(\d+ubuntu\d+\.\d+[\.\da-zA-Z]*)"
    mysql_pattern = r"^([0-9p.]+)-(.*)"
    only_version = r"(\d+(?:\.\d+)*(?:[a-z]\d+)?)"

    # Try to match the SSH pattern first
    match = re.search(ssh_pattern, version)
    if not match:
        # If no SSH match, try the generic pattern
        match = re.search(generic_pattern, version)
    if not match:
        # If no generic match, try the bind pattern
        match = re.search(bind_pattern, version)
    if not match:
        # If no bind match, try the MariaDB pattern
        match = re.search(mariadb_pattern, version)
    if not match:
        # If no MariaDB match, try the Mysql pattern
        match = re.search(mysql_pattern, version)
    if not match:
        # If no Mysql match, try the only_version pattern
        match = re.search(only_version, version)

    if match:
        if len(match.groups()) == 2:
            version = match.group(1)
            path = match.group(2)
            combined_version = f"1:{version}-{path}"
            return combined_version
        else:
            version = match.group(1)
            return version


def sanitize_path(path):
    # Remove non-numeric parts and convert to list of integers
    if path == "":
        return []
    path = re.sub(r"[^0-9.]", "", path)
    return list(map(int, path.split(".")))


def compare_versions(user_version, fixed_version):
    """Compares two version strings numerically."""
    user_parts = sanitize_path(user_version)
    fixed_parts = sanitize_path(fixed_version)
    return user_parts >= fixed_parts


def get_fixed_version(user_version, release, fixed_versions):
    for version_release, version in fixed_versions:
        fixed_version_split = version.rsplit("-", 1)[0]
        if version_release == release:
            if user_version.startswith(fixed_version_split) or user_version[
                2:
            ].startswith(fixed_version_split):
                return version
    return False


def transform_version_to_json(version, ubuntu_version_fixed):
    model = GPT4All("Meta-Llama-3-8B-Instruct.Q4_0.gguf")
    with model.chat_session():
        prompt_user_version = (
            "You are responsible for parsing a banner representing the version of some software, "
            "and outputting a JSON in standard format. The banner may have different formats, here are a few examples:\n"
            "Given this string '1:8.9p1-3ubuntu0.10', you should output:\n"
            "{\n"
            '  "version": "8.9p1",\n'
            '  "path": "0.10"\n'
            "}\n"
            "Given this string '1:6.6p1-2ubuntu2.13+esm1', you should output:\n"
            "{\n"
            '  "version": "6.6p1",\n'
            '  "path": "2.13+esm1"\n'
            "}\n"
            f"Now, parse the user's version: '{version}' into JSON format. \n"
            "Answer only with the JSON format."
        )
        prompt_fixed_version = (
            "You are responsible for parsing a banner representing the version of some software, "
            "and outputting a JSON in standard format. The banner may have different formats, here are a few examples:\n"
            "Given this string '1:8.9p1-3ubuntu0.10', you should output:\n"
            "{\n"
            '  "version": "8.9p1",\n'
            '  "path": "0.10"\n'
            "}\n"
            "Given this string '1:6.6p1-2ubuntu2.13+esm1', you should output:\n"
            "{\n"
            '  "version": "6.6p1",\n'
            '  "path": "2.13+esm1"\n'
            "}\n"
            f"Now, parse the user's version: '{ubuntu_version_fixed}' into JSON format. \n"
            "Answer only with the JSON format."
        )
        response_user_version = model.generate(prompt_user_version, max_tokens=1024)
        response_fixed_version = model.generate(prompt_fixed_version, max_tokens=1024)

    json_user_version = json.loads(response_user_version)
    json_fixed_version = json.loads(response_fixed_version)

    return json_user_version, json_fixed_version


def compare_json_versions(user_json, fixed_json):
    if user_json["path"] == "" and fixed_json["path"] == "":
        user_path = sanitize_path(user_json["version"])
        fixed_path = sanitize_path(fixed_json["version"])
        return user_path >= fixed_path
    else:
        user_path = sanitize_path(user_json["path"])
        fixed_path = sanitize_path(fixed_json["path"])
        # Compare the paths directly as lists of integers
        return user_path >= fixed_path


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Pass the CVE identification and version of SSH/Bind/MariDB. Also you can pass the release of the version"
    )
    parser.add_argument("cve_id", help="CVE Identification", type=str)
    parser.add_argument("version", help="SSH-Ubuntu version", type=str)
    parser.add_argument("release", help="Release of version", type=str)
    args = parser.parse_args()

    cve_id = args.cve_id
    version = args.version
    release = args.release

    is_vulnerable = check_vulnerability(cve_id, version, release)

    combined_version = parse_version(version)
    ubuntu_version_fixed = get_fixed_version(combined_version, release)

    print("RESPONSE OF THE PYTHON PROGRAM:")
    if is_vulnerable:
        print(f"The version: {version} is vulnerable to {cve_id}")
    elif is_vulnerable == False:
        print(f"The version: {version} is NOT vulnerable to {cve_id}")
    else:
        print(
            f"No fixed versions have been found for this {version} version in this {cve_id}"
        )

    if ubuntu_version_fixed != False:
        response_gpt4all = transform_version_to_json(
            combined_version, ubuntu_version_fixed
        )

        json_user, json_fixed = transform_version_to_json(
            combined_version, ubuntu_version_fixed
        )
        vulnerable_json = compare_json_versions(json_user, json_fixed)

        print("RESPONSE OF COMPARATION JSON VERSION:")
        if vulnerable_json:
            print(f"The user's version is: NOT vulnerable to {cve_id}")
        elif vulnerable_json == False:
            print(f"The user's version is: Vulnerable to {cve_id}")
        else:
            print(
                f"No fixed versions have been found for this version in this {version} in this {cve_id}"
            )
